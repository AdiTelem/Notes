/*
 * Copyright (c) 2019 PlanGrid, Inc. All rights reserved.
 */

package com.plangrid.android.mvi

import com.jakewharton.rxrelay2.Relay
import io.reactivex.Observable
import io.reactivex.Scheduler
import io.reactivex.disposables.CompositeDisposable
import io.reactivex.rxkotlin.addTo
import timber.log.Timber

/**
 * This class represents the new [State] of the Mobius and an optional set of [Effect]s and/or [Event]s that should be processed.
 *
 * See [MobiusViewModel] documentation for more context.
 */
data class Next<out State : Any, out Effect : Any, out Event : Any>(
    val state: State,
    val effects: Set<Effect> = emptySet(),
    val events: Set<Event> = emptySet(),
) {
    constructor(state: State, effect: Effect?, event: Event) : this(state, effect.toSingletonSetIfPresent(), setOf(event))
    constructor(state: State, effect: Effect) : this(state, setOf(effect), emptySet())
    constructor(state: State, effects: Set<Effect>, event: Event) : this(state, effects, setOf(event))

    class Builder<State : Any, Effect : Any, Event : Any>(
        val currentState: State,
        private var effects: MutableSet<Effect> = mutableSetOf(),
        private var events: MutableSet<Event> = mutableSetOf(),
    ) {

        fun build(state: State): Next<State, Effect, Event> {
            return Next(state, effects.toSet(), events.toSet())
        }

        fun addEffect(effect: Effect) {
            effects.add(effect)
        }

        fun addEffects(effects: Set<Effect>) {
            this.effects.addAll(effects)
        }

        fun addEvent(event: Event) {
            events.add(event)
        }
    }
}

private fun <T : Any> T?.toSingletonSetIfPresent(): Set<T> =
    this?.let { setOf(it) } ?: emptySet()

/**
 * Given a previous [State] and an [Action], this class generates the [Next] object with the new [State]. Optionally, it might contain a
 * set of [Effect]s and [Event]s that should be processed.
 *
 * See [createRenderableStream] for more documentation.
 */
@Deprecated(
    "Use NextUpdater for better API around Next object creation",
    ReplaceWith("NextUpdater<State, Action, Effect, Event>", "com.plangrid.android.mvi.NextUpdater")
)
typealias Updater<State, Action, Effect, Event> = (currentState: State, action: Action) -> Next<State, Effect, Event>

/**
 * Provides improved API around [Next] object creation. You no longer have to create [Next] objects yourself. By overriding [next] method,
 * you can simply call [Next.Builder.addEffect], [Next.Builder.addEvent] and return a new [State]. Based on those method calls and the
 * returned state object, a new [Next] instance will be created.
 *
 * Sample usage:
 *
 *  override fun Next.Builder<State, Effect, Event>.next(action: Action): State {
 *      return when (currentState) {
 *          is State.Data -> {
 *              addEvent(Event)
 *              currentState.copy(model = Model("hello", 1231L))
 *          }
 *          is State.Loading -> State.Data("123", Model("tittle", 123L))
 *          State.NotInitialized -> {
 *              addEffect(Effect.FetchData("123"))
 *              State.Loading("uid")
 *          }
 *     }
 * }
 */
interface NextUpdater<State : Any, Action : Any, Effect : Any, Event : Any> : Updater<State, Action, Effect, Event> {
    override fun invoke(currentState: State, action: Action): Next<State, Effect, Event> {
        val nextBuilder = Next.Builder<State, Effect, Event>(currentState)
        return nextBuilder.build(nextBuilder.next(action))
    }

    fun Next.Builder<State, Effect, Event>.next(action: Action): State
}

fun <State : Any, Action : Any, Effect : Any, Event : Any> Updater<State, Action, Effect, Event>.debug() =
    { currentState: State, action: Action ->
        Timber.d("Current:$currentState\nAction:$action")
        this(currentState, action).also {
            Timber.d("Next: $it")
        }
    }

/**
 * Base type for [Effect]s that should be run on the UI thread.
 */
interface UIEffect

/**
 * Takes an [Effect] that was generated by the [Updater] and performs some async task (db/network operation, etc...). Once that
 * task is completed, the result should be mapped to an [Action] object that will be sent back into the Mobius loop's
 * [MobiusViewModel.renderDataStream] through the [MobiusViewModel.effectRelay].
 */
typealias Processor<Effect, Action> = (effects: Observable<Effect>) -> Observable<out Action>

/**
 * Takes an [Action] in order to dispatch it to its associated [Mobius] loop.
 */
typealias Dispatcher<Action> = (Action) -> Unit

typealias StateLogger<State> = (currentState: State) -> Unit

/**
 * "Frontends" – Activities, Fragments, Views – should consume this when using [Mobius]
 * It provides a [RenderData] instance, which is the data that the frontend should bind to.
 * It also provides a [Dispatcher], which allows the frontend to dispatch [Action]s back to the [Mobius].
 */
data class Renderable<RenderData, Action>(val data: RenderData, val dispatcher: Dispatcher<Action>)

/**
 * Pure function: Takes the current [State] and a [Dispatcher] and returns an instance of [Renderable].
 */
typealias RenderableFactory<State, Action, RenderData> =
    (currentState: State, dispatcher: Dispatcher<Action>) -> Renderable<RenderData, Action>

/**
 * Pure function: Takes the current [State] and returns an instance of [RenderData]
 * Used to create instances of [Renderable].
 */
typealias StateMapper<State, RenderData> = (currentState: State) -> RenderData

class SpammyLogger<State : Any>(val tag: String) : StateLogger<State> {
    override fun invoke(currentState: State) {
        Timber.tag(tag).d("State: %s", currentState)
    }
}

interface Mobius<Action : Any, Effect : Any, State : Any, RenderData : Any, Event : Any> {
    val initialState: State

    val initialEffects: Set<Effect>

    val updater: Updater<State, Action, Effect, Event>

    val processor: Processor<Effect, Action>?

    val stateMapper: StateMapper<State, RenderData>

    fun renderableFactory(state: State, dispatcher: Dispatcher<Action>): Renderable<RenderData, Action> {
        return Renderable(stateMapper(state), dispatcher)
    }

    /**
     * Your front end should bind to [Renderable.data] and send data back to the Mobius via [Renderable.dispatcher]
     */
    val renderableStream: Observable<out Renderable<RenderData, Action>>

    /**
     * Helper utility, which allows you to observe changes to [Renderable.data] directly
     */
    val renderDataStream: Observable<out RenderData>

    /**
     * Allows your front end to send [Action]s to the Mobius loop for updating and processing
     */
    fun dispatch(action: Action) = actionRelay.accept(action)

    /**
     * This is used so that effects resulting from update() can be processed in action stream
     */
    val effectRelay: Relay<Effect>

    val actionRelay: Relay<Action>

    val eventRelay: Relay<Event>

    val effectsScheduler: Scheduler

    val uiScheduler: Scheduler

    val mainThreadCheck: (Thread) -> Boolean

    val disposables: CompositeDisposable
}

/**
 * The main loop of this Mobius that provides the latest [RenderData]. The internal [State] can be modified only through [Action]s.
 *
 * The inputs to this loop are the following [Action] sources:
 *
 *  1. Stream of [Action]s ([actionRelay]) that are generated by user's input.
 *  2. Stream of [Action]s that are generated by the [Processor] upon processing an [Effect].
 *
 *  An [Action] is converted into a [Next] by the [Updater]. This [Next] object contains the new [State] of this Mobius, and optionally
 *  contains [Effect]s to be processed by the [Processor] and/or [Event]s to be broadcast synchronously to consumers.
 *
 *  The [Observable.scan] operator received the latest [Action] (from either [actionRelay] or [processedEffectsStream]) AND the previous
 *  [Next] object emitted by the [Updater] in the previous loop. This allows us to call the [Updater] with the latest [Action] and the
 *  previous [State] (which is extracted from the previous [Next] stored in the scan operator).
 *
 *  Once the [Updater] emits a [Next] object and the latest [Next] object is stored in the [Observable.scan] operator, [Effect]s and
 *  [Event]s that are stored in the [Next] object can be processed.
 *
 *  [Effect]s are fed into the [effectRelay], which is the input to the [Processor]. By default, [Effect]s are sent to the [Processor] on
 *  a background thread using [effectsScheduler]. While that's ideal for async task processing, some [Effect]s are better suited to be
 *  processed on the UI thread. To emit an [Effect] on a UI thread, mark the [Effect] with [UIEffect] interface.
 *
 *  [Event]s are synchronously fed into the [eventRelay] on the UI thread. Consumers who subscribe to [eventRelay] of this [Mobius]
 *  will receive events on the UI thread without a delay. Use [Event]s to notify others that an event has happened without having to
 *  store that information in the [State].
 */
fun <Action : Any, Effect : Any, State : Any, RenderData : Any, Event : Any>
Mobius<Action, Effect, State, RenderData, Event>.createRenderableStream(logger: StateLogger<State>? = null):
    Observable<out Renderable<RenderData, Action>> =
    Observable
        .merge(
            processedEffectsStream(),
            actionRelay
        )
        .observeOnMainIfNecessary(mainThreadCheck, uiScheduler)
        .doOnNext {
            check(mainThreadCheck(Thread.currentThread())) {
                "Actions must be emitted on the UI thread. Current thread: ${Thread.currentThread()}"
            }
        }
        .scan(Next<State, Effect, Event>(initialState)) { nextWithCurrentState, action ->
            updater(nextWithCurrentState.state, action)
        }
        .doAfterNext {
            if (!it.effects.isNullOrEmpty()) {
                it.effects.forEach { effect -> effectRelay.accept(effect) }
            }

            if (!it.events.isNullOrEmpty()) {
                it.events.forEach { event -> eventRelay.accept(event) }
            }
        }
        .map { it.state }
        .doOnNext { state -> logger?.invoke(state) }
        .map { renderableFactory(it, ::dispatch) }
        .distinctUntilChanged()
        .doOnError(Timber::e)
        .replay(1)
        .also {
            it.connect().addTo(disposables)
        }

/**
 * Sets up the machinery for processing [Effect]s and emitting [Action]s once processed.
 *
 * Upon receiving an [Effect] from [effectRelay], few threading checkes are performed:
 *  1. If an [Effect] is a [UIEffect], which should be processed on a UI-thread, ensure it is emitted on the UI thread by using
 *   [uiScheduler].
 *  2. Otherwise, it is an [Effect] that should be processed asynchronously on a background thread. Use [effectsScheduler] to ensure of
 *  that.
 */
fun <Action : Any, Effect : Any, State : Any, RenderData : Any, Event : Any>
Mobius<Action, Effect, State, RenderData, Event>.processedEffectsStream(): Observable<out Action> {
    return when (val effectProcessor = processor) {
        null -> Observable.empty()
        else -> {
            val effects = effectRelay
                .startWith(initialEffects)

            fun Observable<Effect>.ensureCorrectThreadingByType(): Observable<Effect> {
                return flatMap { effect ->
                    val isUiThread = mainThreadCheck(Thread.currentThread())
                    val value = Observable.just(effect)
                    /**
                     * If it is a [UIEffect] and we are NOT on the UI thread, ensure to apply the [uiScheduler].
                     */
                    if (effect is UIEffect && !isUiThread) {
                        value.subscribeOn(uiScheduler)
                    }
                    /**
                     * If it is NOT a UI [Effect] and we are on the UI thread, ensure to apply the [effectsScheduler].
                     */
                    else if (effect !is UIEffect && isUiThread) {
                        value.subscribeOn(effectsScheduler)
                    }
                    /**
                     * Stay on the same thread.
                     */
                    else {
                        value
                    }
                }
            }
            effectProcessor(effects.ensureCorrectThreadingByType())
                .observeOnMainIfNecessary(mainThreadCheck, uiScheduler)
        }
    }
}

/**
 * Ensures that downstream consumers will receive items on the [uiScheduler].
 */
private fun <T : Any> Observable<T>.observeOnMainIfNecessary(
    mainThreadCheck: (Thread) -> Boolean,
    uiScheduler: Scheduler
): Observable<T> {
    return concatMap {
        val value = Observable.just(it)
        if (!mainThreadCheck(Thread.currentThread())) {
            value.subscribeOn(uiScheduler)
        } else {
            value
        }
    }
}
